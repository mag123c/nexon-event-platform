```
아래 서술들은, 구현 과정에서의 고민들을 1차로 쭉 나열한 뒤 정리한 내용들입니다.
```

#### 1. 구조
기본적인 Layered Architecture(LA)를 바탕으로 설계하되, 의존성 관리를 개선하고자 클린 아키텍처의 원칙을 도입했습니다. 특히 도메인 계층을 중심으로 방향성을 고정하고, 인터페이스와 구현체 분리를 통해 애플리케이션 계층과 인프라 계층 간의 결합도를 줄이고자 했습니다.
- `Domain 계층`: 비즈니스 핵심 모델과 규칙을 순수하게 정의합니다.    
- `Application 계층`: 유즈케이스 단위의 흐름을 정의하며, 외부 의존성 없이 도메인 포트 인터페이스만 사용합니다.
- `Infrastructure 계층`: 실제 DB 접근, 해싱, JWT 발급 등 기술 구현을 담당하며, 인터페이스를 구현하는 어댑터 역할을 합니다.    
- 각 마이크로서비스는 위 계층 분리를 기반으로 독립적으로 구성하며, Gateway → Service 간에는 인터페이스를 통한 느슨한 결합 구조를 지향했습니다.
	 
#### 2. 회원가입 / 로그인
###### 1.`비밀번호 암호화에 대한 고민`
- `문제 인식`: 최근 다양한 보안 이슈 사례등을 통해 관심이 생겼고, 특히 5월초 Typescript Backend Meetup 행사의 보안 세션에서 하드웨어의 발전에 따라 단순 CPU 연산만 수행하는 암/복호화 알고리즘은 탈취 시 까지 오랜 시간이 걸리지 않는다는 것을 인지했음.
- `해결`: 암/복호화 시 메모리 연산을 수행하는 argon2 알고리즘을 적용

###### 2.`로그인`
- `문제 인식`: 2-1과 상동.
- `구현 방향에 대한 생각(미적용)`: 실제 구현하진 않았지만, JWT를 사용하기 때문에 민감정보들을 담지 않고, RTR을 통한 Refresh Token의 OTP화를 구현할 수 있도록 구성. 추가로 로그인 시도 임계치를 게이트웨이에 적용하여 해시도스 등의 공격을 차단하고 알림 체계를 구축할 수 있음.
	
#### 3. Gateway
###### 1. `게이트웨이에서 유저 인증의 책임의 범위에 대한 고민`
- `최초`: DB Fetching을 통해 유저 검증.
- `문제`: 게이트웨이는 최초 진입 지점으로 DB에 직접 접근할 때 병목 및 결합도의 증가가 있을 것 같다고 판단.
- `해결`: JWT 자체만 검사한 후, 게이트웨이 요청에 대한 식별 헤더를 남겨서 요청 전송한다. JWT의 Access Token exp를 짧게 두어 발급된 Access Token을 일차적으로 신뢰하며, RTR을 적용해, Refresh Token을 통한 Access Token 재발급 시 Refresh Token을 초기화.
- `확장`: 특정 API (이벤트 보상 지급) 에서는, 내부 서버 간 통신을 통해 (Event <-> Auth) JWT가 신뢰할 수 있는지 직접 DB Fetching을 통해 검증할 수 있다. 사용자의 로그아웃, 관리자의 특정 세션 만료 처리등은 무효화된 토큰 처리를 추가하여 Redis 등의 캐시성 저장소에 토큰 철회를 게이트웨이에서 사전 검사할 수 있을 것 같다.