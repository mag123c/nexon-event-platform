```
아래 서술들은, 구현 과정에서의 고민들을 1차로 쭉 나열한 뒤 정리한 내용들입니다.
```

#### 1. 구조
기본적인 Layered Architecture(LA)를 바탕으로 설계하되, 의존성 관리를 개선하고자 클린 아키텍처의 원칙을 도입했습니다. 특히 도메인 계층을 중심으로 방향성을 고정하고, 인터페이스와 구현체 분리를 통해 애플리케이션 계층과 인프라 계층 간의 결합도를 줄이고자 했습니다.
- `Domain 계층`: 비즈니스 핵심 모델과 규칙을 순수하게 정의합니다.    
- `Application 계층`: 유즈케이스 단위의 흐름을 정의하며, 외부 의존성 없이 도메인 포트 인터페이스만 사용합니다.
- `Infrastructure 계층`: 실제 DB 접근, 해싱, JWT 발급 등 기술 구현을 담당하며, 인터페이스를 구현하는 어댑터 역할을 합니다.    
- 각 마이크로서비스는 위 계층 분리를 기반으로 독립적으로 구성하며, Gateway → Service 간에는 인터페이스를 통한 느슨한 결합 구조를 지향했습니다.
	 
#### 2. 회원가입 / 로그인
###### 1.`비밀번호 암호화에 대한 고민`
- `문제 인식`: 최근 다양한 보안 이슈 사례등을 통해 관심이 생겼고, 특히 5월초 Typescript Backend Meetup 행사의 보안 세션에서 하드웨어의 발전에 따라 단순 CPU 연산만 수행하는 암/복호화 알고리즘은 탈취 시 까지 오랜 시간이 걸리지 않는다는 것을 인지했음.
- `해결`: 암/복호화 시 메모리 연산을 수행하는 argon2 알고리즘을 적용

###### 2.`로그인`
- `문제 인식`: 2-1과 상동.
- `구현 방향에 대한 생각(미적용)`: 실제 구현하진 않았지만, JWT를 사용하기 때문에 민감정보들을 담지 않고, RTR을 통한 Refresh Token의 OTP화를 구현할 수 있도록 구성. 추가로 로그인 시도 임계치를 게이트웨이에 적용하여 해시도스 등의 공격을 차단하고 알림 체계를 구축할 수 있음.
	
#### 3. Gateway
###### 1. `게이트웨이에서 유저 인증의 책임의 범위에 대한 고민`
- `최초`: DB Fetching을 통해 유저 검증.
- `문제`: 게이트웨이는 최초 진입 지점으로 DB에 직접 접근할 때 병목 및 결합도의 증가가 있을 것 같다고 판단.
- `해결`: JWT 자체만 검사한 후, 게이트웨이 요청에 대한 식별 헤더를 남겨서 요청 전송한다. JWT의 Access Token exp를 짧게 두어 발급된 Access Token을 일차적으로 신뢰하며, RTR을 적용해, Refresh Token을 통한 Access Token 재발급 시 Refresh Token을 초기화.
- `확장`: 특정 API (이벤트 보상 지급) 에서는, 내부 서버 간 통신을 통해 (Event <-> Auth) JWT가 신뢰할 수 있는지 직접 DB Fetching을 통해 검증할 수 있다. 사용자의 로그아웃, 관리자의 특정 세션 만료 처리등은 무효화된 토큰 처리를 추가하여 Redis 등의 캐시성 저장소에 토큰 철회를 게이트웨이에서 사전 검사할 수 있을 것 같다.

#### 4. 이벤트 등록
###### 1. `이벤트 조건에 대한 유효성 검증`
- `고민`: 이벤트 생성 시 조건(condition) 필드의 유효성 검증을 어디까지, 그리고 어느 계층에서 수행해야 할까? 단순 DTO 유효성 검증 파이프만으로 충분할까?
- `구현 방향`: 이벤트 조건은 카테고리(category), 타입(type), 연산자(operator), 값(value) 등 다양한 요소로 구성해두었고, 이들의 조합은 시스템에서 정의한 규칙(SUPPORTED_EVENT_TYPES 등)을 따라야 한다. 단순 형식 검증 외에 `"지원하는 조건 조합인가?"`, `"조건 값의 의미가 타입/연산자와 부합하는가?"` 등 비즈니스 규칙에 따른 의미론적 검증이 필요하다고 판단함.
- `해결`: 유스케이스(CreateEventUseCase)의 책임으로 명확화하여 이벤트 조건의 의미론적 유효성 검증은 CreateEventUseCase 내에 validateEventConditions private 메소드로 분리하여 구현했다. 설정 기반 검증: SUPPORTED_EVENT_TYPES 설정을 통해 지원하는 조건 카테고리 및 타입 조합을 명확히 정의하고, 유스케이스는 이 설정을 참조하여 검증을 수행한다. 유효하지 않은 조건 발견 시 early-return한다.
- `확장`: 조건 검증 로직이 매우 복잡해지거나 여러 유스케이스에서 재사용될 경우, 별도의 EventConditionValidationService (application/services 내부)로 분리하여 유스케이스의 의존성을 낮춤. 1차 구현을 마치고 보니,  유스케이스 내부에서 mongoose의 PK(Types.ObjectId)에 직접 의존하는 경우가 있었고 이는 비즈니스 영역에서 특정 DB에 의존적이기 때문에 Factory 패턴을 통해 분리하여 사용함.

#### 5. 보상
###### 1. `보상 수량 관리`
- `고민`: 요구사항의 보상 조건이 `수량`을 포함한다는 언급이 있음.
- `구현`:
    - 보상 등록 시 총 수량을 등록하는 흐름으로 이해하고 quantity를 설정, DB에서 remainQuantity를 사용. quantity 입력값이 없다면 보상 수량이 무제한이라고 가정.
    - 보상은 quantity가 남은 것들만 전체 제공하는 방법으로 결정하여 구현하였음. (유저가 선택하여 보상을 받을 수 있는 상황 등은 구현되지 않음)

###### 2. `보상 신청(Claim)`
- `고민`: 보상 신청 > 수령 시 트랜잭션 처리. 이벤트서버에서 Auth(User)서버로 유저 활동 내역을 가져와야하는데, 어느 계층에서 역할을 수행하게 할 지
- `트랜잭션 처리`: 보상 콜렉션의 quantity처리와 보상 신청 로그 등록에 moongooseSessioon을 인자로 넘겨 트랜잭션을 보장
- `Auth서버와의 연동`: event-core의 애플리케이션 영역에 애플리케이션의 포트를 구성하고 실제 구현체를 인프라 영역의 adapter계층에 nestjs HttpModule을 사용한 실제 구현체를 통해 Auth서버에서 유저의 활동 내역을 가져오도록 처리.